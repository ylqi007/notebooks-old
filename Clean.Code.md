# 序
**小处诚实非小事**

# 1. 整洁代码

# 2. 有意义的命名
## 2.1 介绍
软件中随处可见命名。我们给变量、函数、参数、类和封包命名。我们给源代码及源代码所在的目录命名。我们给jar文件、war文件命名。**我们不断的命名，既然有这么多命名要做，不妨做好它。**

## 2.2 名副其实
选个好名字要花时间，但省下来的时间比花掉的多。注意命名，而且一段发现有更好的名称，就换掉旧的。这么多，读你代码的人都会更开心。

变量、函数或类的名称应该已经答复了所有的大问题。它应该告诉你，它为什么存在，它做什么事，应该怎么用。如果名称需要额外的注释补充，那就不算名副其实。
```java
int d;  // 消逝的时间，以日计

int elapsedTimeInDays;
int daysSinceCreation;
int daysSinceModification;
int fileAgeinDays;
```
* 名称`d`什么也没有说明，它没有引起对时间消逝的感觉，更别说`以日计`。我们应该选择指明了计量对象和计量单位的名称。

选择体现本意的名称让人更容易理解和修改代码。
```java
public List<int[]> getThem() {
    List<int[]> list1 = new ArrayList<int[]>();
    for(int[] x: theList) {
        if(x[0] == 4) 
            list1.add(x);
    }
    return list1;
}
```
* 上面代码片段难以说明要做的事情。上面代码没有复杂的表达式，空格和缩进中规中矩，只有三个变量和两个常量。看似很简单，但依然难以说明代码要做的事情。
* 问题不在于代码的简洁度，而在于代码的**模糊度**：即上下文在代码中未被明确体现的程度。
  1. `theList`中是什么类型的东西？
  2. `x[0]`中`0`下标的意义是什么？
  3. 值`4`的意义是什么？
  4. 我怎么使用返回的列表？
上述问题的答案没有体现在代码中，可那就是它们应该在的地方。


## 2.3 避免误导
程序员必须避免留下掩藏代码本意的错误线索，应当避免使用与本意相悖的词。
* 比如，别用`accountList`来指称一组账号，除非它真的是`List`类型。`List`一词对程序员有特殊的意义。如果包纳账号的容器并非真的是个`List`,就会引起错误的判读。所以，使用`accountGroup`或`bunchOfAccounts`，甚至直接用`accounts`都会好一些。

提防使用不同之处较小的名称。
* 比如`XYZControllerForEfficientHandlingOfStrings`和 `XYZControllerForEfficientStorageOfStrings`，会花多少时间区分这两个名称？这两个词外形是在太相似了。

以同样的方式贫血出同样的概念才是信息。拼写前后不一致就是误导。
* 误导性名称的可怕例子：小写字母`l`和大写字母`O`作为变量名。它们看起来很像常量`1`和`0`.


## 2.4 做有意义的区分
如果程序员只是为了满足编译器或解释器的需要而写代码，就会制造麻烦。例如，为了同一作用范围内两个不同的东西不能重名，你可能会随时改掉其中一个名称。有时候干脆以错误的拼写充数，结果就是出现在更正拼写错误后导致编译器出错的情况。

光是添加数字系列或是废话是远远不够的，即便这足以让编译器满意。如果名称必须不同，那么其意思也应该不同才对。

```java
getActiveAccount();
getActiveAccounts();
getActiveAccountInfo();
```
* 对于上述几个函数，程序员怎么能知道该调用哪个函数？

如果缺少明确的约定，变量`moneyAccount`就与`money`没区别，`customerInfo`与`customer`没区别，`accountData`与`account`没缺别，`theMessage`与`message`没区别。


## 2.5 使用读的出的名称
如果名称读不出来，讨论的时候就会像个傻鸟。


## 2.6 使用可搜索的名称
单字母名称和数字敞亮有个问题，就是很难在一大篇文字中找出来。比如，找`MAX_CLASSES_PER_STUDENT`很容易，但是想找数据7就麻烦了，它可能是某些文件名或其他常量定义的一部分，出现在因不同意图而采用的各种表达式中。

窃以为单字母名称**仅**用于短方法中的本地变量。名称长短应与其作用域大小相对应。若变量或常量可能在代码中多处使用，则应赋予其以便搜索的名称。
```java
for(int j=0; j<34; j++) {
    s += (t[j]*4)/5;
}


int realDaysPerIdealDay = 4;
coutn int WORK_DAYS_PER_WEEK = 5;
int sum = 0;
for(int j=0; j<NUMBER_OF_TASKS; j++) {
    int realTaskDays = taskEstimate[j] * realDaysPerIdealDay;
    int realTaskWeeks = (realdays / WORK_DAYS_PER_WEEK);
    sum += realTaskWeeks;
}
```
* 第一段代码中使用的变量`s, t, j`和常量`4, 5`都是难以搜索的。
* 第二段代码中虽然`sum`并非特别有用的名称，不过它至少可以搜得到。


## 2.7 避免使用编码
编码已经太多了，无谓再自找麻烦。把类型或作用域编进名称里，突然增减了代码的负担。

### 2.7.1 匈牙利语标记法

### 2.7.2 成员前缀
不必用`m_`前缀来标明成员标量。应当把类和函数做的足够小，消除对成员前缀的需要。

此外，人们会很快学会无视前缀(或后缀)，只看到名称中有意义的部分。代码读得越多，严重就越没有前缀。最终，前缀变作了不如法眼的废料，变作了旧代码的标志物。

### 2.7.3 接口和实现


## 2.8 避免思维映射
不应当让读者在脑中把你的名称翻译成他们熟知的名称。这种问题经常出现在选择是使用问题领域术语还是解决方案领域术语时。

聪明程序员和专业程序员之间的区别在于，专业程序员了解，**明确是王道**。专业程序员善用其能，编写其他人能理解的代码。 


## 2.9 类命
类命和对象名应该是名词或名词短语，如Customer、WikiPage、Account和AddressParse。避免使用Manager、Processor、Data或Info这样的类命。类命不应当是动词。


## 2.10 方法命
方法命应当是动词或动词短语，如postPayment、deletePage或save。属性访问器、修改器和断言应该根据其值命名，并依照Javabean标准加上get、set和is前缀。


## 2.11 别扮可爱


## 2.12 每个概念对应一个词
给每个抽象概念选一个词，并且一以贯之。例如，使用fetch、retrieve和get来给在多个类中的同种方法命名。
对于那些会用到你的代码的程序员，一以贯之的命名法简直就是天降福音。


## 2.13 别用双关语
避免将同一单词用于不同目的。同一术语用于不同概念，基本就是双关语了。如果遵循**一词一义**规则，可能在好多个类中都会有add方法，只要这些方法的参数列表和返回值在语义上等价，就一切顺利。


## 2.14 使用解决方案领域名称


## 2.15 使用源自锁涉问题领域的名称


## 2.16 添加有意义的语境


## 2.17 不要添加没有用的语境



# 3. 函数
本章讨论如何写好函数。

## 3.1 短小
函数的第一个规则是要**短小**。第二条规则是**还要更短小**。经过漫长的试错，总结的经验就是，函数就该短小。

每个函数都一目了然。每个函数都只说一件事。而且，每个函数都依序把你带到下一个函数。这就是函数应该达到的**短小**程度。


**代码块和缩进**

if语句、else语句、while语句等，其中的代码块应该只有一行。该行大抵应该是一个函数调用语句。这样不但能够保持函数短小，而且，因为块内的调用函数拥有比较具有说明性的名称。从而增加了文档上的价值。

这也意味着函数不应该大到足以容纳嵌套结构。所以，函数的缩进层级不该多于一层或两层。当然，这样的函数易于阅读和理解。


## 3.2 只做一件事
**函数应该做一件事。做好这件事，且只做这一件事。**

那么如何定义”一件事“？
如果函数只是做了该函数名下同一抽象层上的步骤，则函数还是只做了一件事。编写函数毕竟是为了把一些大的概念(换言之，函数的名称)拆分为另一个抽象层次上的一系列步骤。

要判断函数是否不止做了一件事，还有一个方法，就是看是否能够再拆分出一个函数，该函数不仅只是单纯地重新诠释其实现。

**函数中的区段**：比如`generatePrimes`函数被切分为`declarations, initializations`和`sieve`等区段。这就是函数做事太多的明显征兆。只做一件事的函数无法被合理地切分成多个区段。


## 3.3 每个函数一个抽象层级
要确保函数只做一件事，函数中的语句都要在同一抽象层次上。

函数中混杂不同抽象层次，往往让人迷惑。读者可能无法判断某个表达式是基础概念还是细节。更恶劣的是，就像破损的窗户，一旦细节与基础概念混杂，更多细节就会在函数中纠结起来。

**自顶向下读代码：向下规则**
我们想要让代码拥有自顶向下的阅读顺序。我们想要让每个函数后面都跟着位于下一抽象层级的函数，这样以来，在查看函数列表时，就能遵循抽象层级向下阅读了。我们把这叫做**向下规则**。

程序员往往很难学会遵循这条规则，写出只停留在一个抽象层次上的函数。尽管如此，学习这个技巧还是很重要的。这是保持函数短小、确保只做一件事的要诀。让代码读起来像是一系列自顶向下的TO起头段落是保持抽象层级协调一致的有效技巧。


## 3.4 switch语句
将switch语句埋到抽象工厂下，不让任何人看到。该工厂使用switch语句为Employee的派生物创建适当的实体，而不同的函数，如`calculatePay, isPayday, deliverPay`等，则借由Employee接口多态地接受派遣。

对于switch语句，我们的规则是如果只出现一次，用于创建多态对象，而且隐藏在某个继承关系中，则系统中其他部分看不到，就还能容忍。

```java
public abstract class Employee {
    public abstract boolean isPayday();
    public abstract Money calculatepay();
    public abstract void deliverPay(Money pay);
}


public interface EmployeeFactory() {
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
}


public class EmployeeFactoryImpl implements EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployerType {
        switch(r.type) {
            case COMMISSIONED:
                return new CommissionedEmployee(r);
            case HOURLY:
                return new HourlyEmployee(r);
            case SALARIED:
                return new SalariedEmployee(r);
            default:
                throw new InvalidEmployeeType(r.type);
        }
    }
}
```


## 3.5 使用描述性的名称
给每个私有方法取个同样具有描述性的名称，如`isTestable`或`includeSetupAndTeardownPages`。好名称的价值怎么好评价都不为过。记住沃德原则：“如果每个例程都让你感到深合己意，那就是简洁代码。“要遵循这一原则，多半工作都在于为只做好一件事的小函数取个好名字。函数越短小、功能越集中，就越便于取个好名字。

别害怕长名称，长而具有描述性的名称，要比短而令人费解的名称好。长而具有描述性的名称，要比描述性的长注释好。

别害怕花时间取名字。


## 3.6 函数参数
最理想的参数数量是零(零参数函数)，其次是一(单参数函数)，再其次是二(双参数函数)，应尽量避免三(三参数函数)。有足够特殊的理由才能用三个以上参数--所以无论如何也不要这么做。

### 3.6.1 一元函数的普遍形式
向函数传入单个参数有两种极普遍的理由：
1. 操作该参数，将其转换为其他什么东西，再输出之。
2. 还有一种形式就是事件(event)。在这种形式中，有输入参数而无输出参数。程序将函数看作是一个事件，使用该参数修改系统状态。

### 3.6.2 标识参数
标识参数丑陋不堪，向函数传入布尔值简直就是骇人听闻的做法。这样做，方法签名立刻变得复杂起来，大声宣布本函数不止做一件事。如果标识为true将会这样做，标识为false则会那样做。

### 3.6.3 二元函数

### 3.5.4 三元函数

### 3.6.5 参数对象
如果函数看起来需要两个、三个或三个以上参数，就说明其中一些参数应该封装为类了。
```java
Circle makeCircle(double x, double y, double radius);

Cirdle makeCircle(Point center, double radius);
```

### 3.6.6 参数列表

### 3.6.7 动词与关键词


## 3.7 无副作用


## 3.8 分割指令与询问
函数要么做什么事，要么回答什么事，但二者不可兼得。函数应该修改某对象的状态，或是返回该对象的有关信息。两样都干常常会导致混乱。
* 指令：即做什么事
* 询问：即回答什么问题


## 3.9 使用异常代替返回错误码
从指令式函数返回错误码轻微违法了指令与询问分割的规则。它鼓励了在if语句判断中把指令当作表达式使用。
```java
if(deletePage(page) == E_OK)
```
这不会引起动词/形容词混淆，但却导致更深层次的嵌套结构。当返回错误码时，就是在要求调用者立刻处理错误。

另一方面，如果使用异常替代返回错误码，错误处理代码就能从主路径代码中分离出来，得到简化。

### 3.9.1 抽离Try/Catch代码块
Try/Catch代码块丑陋不堪。它们搞乱了代码结构，把错误处理与正常流程混为一谈。最好把try/catch代码块的主体抽离出来，另外形成函数。
```java
public void delete(Page page) {
    try {
        deletePageAndAllReferences(page);
    } catch (Exception e) {
        logError(e);
    }
}

private void deletePageAndAllReferences(Page page) throws Exception {
    deletePage(page);
    registry.deleteReference(page.name);
    configKeys.deleteKey(page.name.makeKey);
}

private logError(Exception e) {
    logger.log(e.getMessage());
}
```

### 3.9.2 错误处理就是一件事
函数应该只做一件事。错误处理就是一件事。因此，处理错误的函数就不该做其他事。这就意味着如果关键字try在某个函数中存在，它就该是这个函数的第一个单词，而且在catch/finally代码块后面也不该有其他内容。

### 3.9.3 Error.java依赖磁铁
返回错误码通常暗示某处有个类或是枚举，定义了所有错误码。
```java
public enum Error {
    OK,
    INVALID,
    NO_SUCH,
    LOCKED,
    OUT_OF_RESOURCES,
    WAITING_FOR_EVENT;
}
```
这样的类就是一块**依赖磁铁(dependency magnet)**;其他许多类都得导入和使用它。

使用异常替代错误码，新异常就可以从异常类派生出来，无需重新编译或重新部署。


## 3.10 别重复自己
**重复**可能是软件中一切邪恶的根源。许多原则与实践规则都是为了控制与消除重复而创建。


## 3.11 结构化编程
有些程序员遵循Edsger Dijkstra的结构化编程规则。Dijkstra认为，每个函数、函数中的每个代码块都应该有一个入口、一个出口。


## 3.12 如何写出这样的函数
写代码和写别的东西很像。在写论文或文章时，你先想什么就写什么，然后再打磨它。初稿也许是粗陋无序，你就斟酌推敲，直至达到你心目中的样子。

遵循本章中列出的规则，仔细打磨斟酌，组装好这些函数。


## 3.13 小结
函数是语言的动词，类是名词。

大师级程序员把系统当作故事来讲，而不是当作程序来写。



# 4. 注释

## 4.1 注释不能美化糟糕的代码


## 4.2 用代码来阐述
```java
// Check to see if the employee is eligible for full benefits
if((employee.flags & HOURLY_FLAG) && (employee.age > 65))
```
vs
```java
if(employee.isEligibleForFullBenefits)
```
* 想上几秒中，就能用代码解释你的大部分意图。很多时候，简单到只需要创建一个描述与注释所言同一事物的函数即可。


## 4.3 好注释

### 4.3.1 法律信息

### 4.3.2 提供信息的注释

### 4.3.3 对意图的解释

### 4.3.4 阐释
有时，注释把某些晦涩难懂的参数或返回值的意义翻译为某种可读的形式，也会是有用的。

### 4.3.5 警示
有时，用于警告其他程序员会出现某种后果的注释也是有用的。

### 4.3.6 TODO注释
有时，有理由用`//TODO`形式再源代码中放置要做的工作列表。

如今，大多数好用的IDE都提供了特别的手段来定位所有TODO注释，这些注释看来丢不了。你不会愿意代码因为TODO的存在而编程一堆垃圾，所以要定期查看，删除不再需要的。

### 4.3.7 放大
注释可以用来方法某种看来不合理之物的重要性。

### 4.3.8 公共API中的Javadoc


## 4.4 坏注释
大多数注释都属于此类。通常，坏注释都是糟糕代码的支撑或接口，或者对错误决策的修正，基本上等于程序员的自说自话。

### 4.4.1 喃喃自语

### 4.4.2 多余的注释

### 4.4.3 误导性注释

### 4.4.4 循轨式注释

### 4.4.5 日志式注释
有人会在每次编辑代码时，在模块开始处添加一条注释。这类注释就像是一种记录每次修改的日志。

很久之前，在模块开始处创建并维护这些记录还算有道理。那时，我们还没有源代码控制系统可用。如今，这种冗长的记录只会让模块变得凌乱不堪，应当全部删除。

### 4.4.6 废话注释

### 4.4.7 可怕的废话

### 4.4.8 能用函数或变量就别用注释

### 4.4.9 位置标记

### 4.4.10 括号后面的注释
有时，程序员会在括号后面放置特殊的注释。尽管这对于含有深度嵌套结构的长函数可能有意义，但只会给我们更愿意编写的短小、封装的函数带来混乱。如果你发现自己想标记右括号，其实应该做的是缩短函数。

### 4.4.11 归属于署名
源代码控制系统非常善于记住谁在何时添加了什么。没必要用那些小小的签名搞脏代码。

注意，源代码控制系统是这类信息最好的归属地。

### 4.4.12 注释掉的代码
直接把代码注释掉是讨厌的做法。别这么干！

其他人不敢删除注释掉的代码。他们会想，代码依然放在那儿，一定有其原因，而且这段代码很重要，不能删除。注释掉的代码堆积在一起，就像破啤酒瓶底的渣滓一样。

### 4.4.13 HTML注释
源代码注释中的HTML标记是一种讨厌物。

如果注释讲由某种工具(例如Javadoc)抽取出来，呈现到网页，那么该是工具而非程序员来负责给注释加上合适的HTML标签。

### 4.4.14 非本地信息
例如你一定要写注释，请确保它描述了离它最近的代码。

### 4.4.15 信息过多
别在注释中添加有趣的历史性话题或者无关的细节描述。

### 4.4.16 不明显的联系

### 4.4.17 函数头
短函数不需要太多描述。为只做一件事的短函数选个好名字，通常要比写函数头注释要好。

### 4.4.18 非公共代码中的Javadoc
虽然Javadoc对于公共API非常有用，单对于不打算作公共用途的代码就令人厌恶了。

### 4.4.19 范例



# 5. 格式
## 5.1 格式的目的
先明确一下，**代码格式**很重要。代码格式不可忽略，必须严肃对待。代码格式关乎沟通，而沟通是专业开发者的头等大事。


## 5.2 垂直格式
**短文件**通常比唱文件易于理解。

### 5.2.1 向报纸学习
源文件要像报纸文章那样。名称应该简单且一目了然。名称本身应该足够告诉我们是否在正确的模块中。源文件最顶部应该给出高层次概念和算法。细节应该往下渐次展开，直至找到源文件中最底层的函数和细节。

### 5.2.2 概念间垂直方向上的区间
几乎所有的代码都是从上往下读，从左往右读。每行展现一个表达式或一个子句，每组代码展示一条完整的思路。**这些思路用空白行区隔开来。

### 5.2.3 垂直方向上的靠近
如果说**空白行**隔开了概念，靠近的代码行则暗示了它们之间的紧密关系。所以，紧密相关的代码应该相互靠近。

### 5.2.4 垂直距离
关系密切的概念应该相互靠近。显然，这条规则并不适用于分布在不同文件中的概念。除非有很好的理由，否则就不要把关系密切的概念放到不同的文件中。时间上，这也是避免使用protected变量的理由之一。

对于那些关系密切、放置于同一源文件中的概念，它们之间的间隔应该成为对相互的易懂度有多重要的衡量标准。应避免迫使读者在源文件和类中跳来跳去。

**变量声明**，变量声明应尽可能靠近其使用位置。因为函数很短，本地变量应该在函数的顶部出现。

**实体变量**应该在类的顶部声明。在Java中，惯例是放在类的顶部。没有理由去遵循其他惯例。重点是在谁都知道的地方声明实体变量，大家应该知道在哪儿能看到这些声明。

**相关函数**。若某个函数调用了另外一个，就应该把它们放到一起，而且调用者应该尽可能放在被调用者上面。这样，程序就有个自然的顺序。若坚定地遵循这条规定，读者将能够确信函数声明总会在其调用后很快出现。

**概念相关**。概念相关的代码应该放到一起。相关性越强，彼此之间的距离就应该越短。

### 5.2.5 垂直顺序
一般而言，我们想自上而下展示函数的调用用依赖顺序。也就是说，被调用的函数应该放在执行调用的函数下面。


## 5.3 横向格式
### 5.3.1 水平方向上的间隔与靠近
我们使用**空格字符**将彼此紧密相关的事物连接到一起，也用空格字符把相关性弱的事物分隔开。

### 5.3.2 水平对齐
> 如今，我更喜欢**不对齐**的声明和赋值。

### 5.3.3 缩进
源文件是一种**继承结构**，而不是一块大纲结构。其中的信息涉及这个文件、文件中每个类、类中的方法、方法中的代码块，也涉及代码块中的代码块。这种继承结构中的每一层级都圈出一个范围，名称可以在其中声明，而声明和执行语句也可以在其中解释。

要让这种范围式继承结构可见，我们根据源代码行在继承结构中的位置对源代码进行**缩进**处理。

**违反缩进规则**。有时，会忍不住想要在短小的if语句、while循环或小函数中违反缩进语句规则。一旦这么做了，我会多数时候还会回头加上缩进。这样就避免了出现**范围层级坍塌到一行**的情况。

### 5.3.4 空范围
有时，while或for语句的语句体为空。不喜欢这种结构，尽量不使用。如果无法避免，就确保空范围体的缩进，用括号包围起来。


## 5.4 团队规则
一组开发者应当认同一种格式风格，每个成员都应该采用那种格式。我们想要让软件用用一以贯之的风格。